/* eslint-disable */
const topic = {
    test: 'Test',
    chat: 'Chat',
    dev: 'Dev',
    tra: 'Travel',
}

export default {
    postList: [
        {
            title: 'pm2 모듈과 멍청이와 git',
            date: 1547716087708,
            topic: topic.dev,
            text: '--토픽을 Dev로 골랐는데 사실 그렇게 개발스러운 얘기를 하지는 않을 것 같다. 근황과 관련된 몇가지 코딩관련 얘기들을 해볼까 한다.  ' +
            '  ' +
            '<h3>1. 멍청이</h3>  ' +
            '--얼마전, 갑자기 무슨 바람이 불었는지 ES6에서 변경된 Javascript문법들을 한번 본적이 있다. 리스트를 하고 있는데, 이런? 생각한 것보다 내가 놓치고 있던 것들이 너무 많았다. 작성했던 코드들이 영화처럼 눈앞을 지나가면서 그때 그 코드를 썼으면 10줄은 줄였을 텐데, 하는 생각이 들었던 것이다. 특히 for문에 초가되었던 for-of구문이 있는데, 그게 그렇게 눈에 들어왔다.  ' +
            '--지금까지 아무것도 모르고 일반 for문으로 배열에 length를 구해서 돌렸던 루프를 생각하면 지구 세바퀴 반은 돌았을 것이다. 그것 말고도 나머지 연산자나 템플릿 문자열과 같이 유용해 보이는 것들이 너무 많았다. 사실 지금까지는 급하게 코드만 짜내는 일을 해왔다. 실력도 초보고 아는것도 없으니 일단 많이 해야한다는 강박이 있었는데, 지금부터는 알아야 할 것들을 파악하고 다시 확인하는 시간이 필요할 것 같다.  ' +
            '--아마 시간이 된다면, 개인적으로 문법을 정리하거나, 지나간 프로젝트들에서 ES6문법을 사용하면 코드를 줄일 수 있는 부분을 찾아서 수정하면서 공부를 진행할 수 있지 않을까 싶다.  ' +
            '  ' +
            '<h3>2. pm2</h3>  ' +
            '--내가 현재 일하는 회사는 특정 소프트웨어를 판매하고 관리하고 커스텀하는 일들을 많이 한다. 그 과정에서 여러가지 테스트를 위한 서버들이나 관리를 위한 서버들이 많은데, 그러한 서버들이 평소에 살아있는지 아닌지 사실 접속하기 전까지는 알 방법이 없다. 그래서 TCP ping을 이용한 서버 생존보고 봇을 만들어 Mattermost에서 알림을 받을 수 있게 했는데, 그 과정에서 서버를 올리기 위해 사용한게 바로 pm2였다.  ' +
            '--pm2를 간단하게 말하면, Node.js서버를 관리해 주는 툴이다. 몇가지 커맨드를 실행해서 서버를 실행하거나 멈추거나 재시작하거나 리스트를 받아볼 수 있다. 그 중에서도 가장 마음에 드는 기능은, 자동 재시작 기능이다. 기본적으로 Node.js서버는 코드에 문제가 있을경우 서버가 꺼져버린다. 죽어버힌다는 얘기다. 테스트 환경에서는 상관이 없지만 불안정한 임시 릴리즈 상황에라면? 이렇게 죽어버려서는 안된다.  ' +
            '--바로 그럴때 pm2는 해다 서버를 다시 살리고 카운트를 표시한다. 그걸 통해서 나는 해당 서버에 문제가 있음을 짐작할 수 있다. 완벽한 서버 호스팅 서비스! 라고 말하는 건 아니다. 단지 그 단계를 도와줄 수 있을 것 같다. 아직 사용하는 도중이라 잘 모르지만, 서버 클러스터링 기능도 있기는 한 것 같았다. Docker + pm2를 이용한 간단한 서버 호스팅도 고려해 볼 만 할 것같다.  ' +
            '  ' +
            '<h3>3. Github private repository</h3>  ' +
            '--깃허브의 클라우드 서버 서비스(그냥 깃허브 페이지)는 일반등급 유저에 대해서는 원래 개인저장소 기능을 지원하지 않았었다. 모두 퍼블릭으로만 가능했는데, 이번달-아니면 저번달 일지도-에 일반 사용자도 몇개의 개인저장소를 만들 수 있도록 변경되었다. 이걸 원래 알고는 있었는데, 사실 나는 그렇게 보안에 유의해야할 작업을 하는 편은 아니라서 쓸 일이 없었다.  ' +
            '--그런데 이번에 위에서 말한 ping 봇을 만들면서 테스트를 하다가, 회사의 서버정보가 담긴 파일을 커밋하고 푸시해버렸던 것이다. 멍청이라고 밝힌 바 이미 벌어진 일이니 수습을 해야겠는데, 만들기 바빠서 고치기가 너무 귀찮았다. 깃으로 rebase해서 해당 커밋 변경하고 하기가 귀찮았던 것이다. 그래서 그냥 개인저장소로 돌려버리자 라는 생각을 했던 것이다.  ' +
            '--실제로 해보니 잘 동작하는 것 같았다. 그런데 이게 버그인지 아니면 의도한건지 모르겠으나, 커밋 이력을 보여주는 초록색 표시에서 master branch에 대한 커밋만 표시가 되는 모양이다. 정작 커밋은 거진 여섯일곱은 했는데 보여지는건 달랑 하나면 뭔가 기분이 좀 그렇다. 초록색을 채우는 맛이 또 있는 것인데 말이다.  ' +
            '--아, 그리고 무슨 상태를 표시하는 status기능이 생겼는데, 사실 그리 쓸모있고 기능이 좋은 부분은 아닌 것 같다. 그냥 그렇구나 싶은 정도?  ' +
            '  ' +
            '<h3>3. git remote set url</h3>  ' +
            '--이건 그냥 내가 까먹을까봐 써놓는 부분이다. 몰랐던 사람은 알아둬도 좋다. git에서 원격저장소 즉 remote repository로 push를 하는 경우는 왕왕있다. Github로의 push는 뭐 말 할 필요도 없는 수준일 것이다. 그런데 public이 아닌 회사나 기타 내부적인 저장소에 push를 해야 할 경우라면? userid나 password를 입력해야 할 것이다.  ' +
            '--위에서 얘기한 Github의 개인저장소에 push를 할때는 터미널을 통해 정보를 받는 것 같기는 했다. 하지만 한가지 명시적으로 사용자 정보를 넘기는 방법도 있다. git을 통해 원격저장소를 remote add를 통해 추가하고 "git remote set-url remote_name https://username:password@gitlab.com/username/repo.git"의 방식으로 username과 password를 추가할 수 있다.  ' +
            '--이미 git remote add를 통해 추가한 원격 저장소의 주소에 set-url을 통해 사용자 정보를 추가하는 방식이다. 처음부터 사용자 정보가 들어간 url로 git remote add를 시도해도 연결이 안되는 것 같았다. 불안한 사람들은 일단 원격 저장소를 추가한 후 사용자 정보를 설정하는 방향으로 해보자. 이것 말고도 사용자 정보를 명시하는 다른 여러 방법들이 있는 것 같기는 한데, 나는 여기서 일단 만족했다.  '
        },
        {
            title: 'OAuth 2.0',
            date: 1550481474501,
            topic: topic.dev,
            text: "<img src='./static/photos/oauth2.png' style='width: 100%; height: auto;' />  " +
            '  ' +
            '<h3>OAuth 2.0에 대한 잡담</h3>  ' +
            '--얼마전에 Github나 Google을 통해 로그인 하는 방법을 연습한 적이 있었다. 설명하는 글을 쓰면서 그러한 인증 방식을 스스로 구현해 보면 재미있겠다는 생각을 했는데, 그래서 <a href="https://github.com/ninanung/3-legged-oauth">했다</a>. OAuth2.0과 3 legged authentication을 이리저리 찾아보고 간단한 구현 수준으로만 만들었다. 당연하지만 그 와중에 OAuth2.0 이라는 것에 대해서 알게 되었다. 간단히 말하자면 사용자들이 특정 웹 서비스에 등록된 자신들의 정보를 다른 웹 서비스나 어플리케이션에서 접근하도록 허가할 때 비밀번호 없이 가능하도록 한, 접근권한 위임을 위한 개방형 표준이다.  ' +
            '--위의 설명은 사실 위키를 참고했으며, 내가 이해한 지식으로 말해보면, 특정 서비스를 사용할 때 다른 서비스에 이미 있는 사용자 정보를 통해 접속 가능하도록 하는 인증 방식이라는 것이다. 사실 이러한 시도를 한 것은 OAuth가 처음은 아니다. 옛날에 OpenID라는 개념이 있었는데, 이는 일종의 공용 로그인 서비스로 특정 OpenID에서 가입한 유저 정보를 통해 다른 곳에서도 로그인이 가능하도록 했던 것이다. 결론부터 말하자면, 그 당시에 꽤나 획기적인 방식이라는 평을 들으며 유행을 하긴 했으나 의미있는 수준으로 사용되었는지는 미지수이다. 조금 찾아보니 아직도 존재하기는 하는 것 같으나, OAuth2.0과 같이 사용되는 모양이라 사실상 그냥 OAuth2.0 라고 봐야할 것 같다.  ' +
            '--OAuth에 대한 설명을 간단히 하자면, 웹 개발자라면 익숙할 수 있는, Token(토큰)을 발급받는 일련의 과정이라고 할 수 있다. 토큰이란 일종의 열쇠와 같은 개념으로, 사용자의 정보에 접근할 수 있는 키가 된다. 물론 클라이언트(정보에 접근하고자 하는 어플리케이션)는 사전에 등록을 완료한 상태여야 하며 키를 받는다고 해도 보통은 그 키(토큰)에는 만료되는 기간이 있어서 무한정 사용하지 못하는 경우가 대부분이다. 만료가 될 경우에는 해로 토큰을 받아야 하며, 이러한 일련의 과정이 보안성을 더 높일 수 있다.  ' +
            '--이러한 점은 초기의 OpenID와의 차이점 이기도 한데, 초기의 OpenID인증은 사용자가 인증을 완료하면 사용자 정보를 바로 넘겨주었다. 하지만 OAuth2.0 방식은 토큰을 발급하고 발급받은 토큰을 요청의 헤더에 추가하지 않는 이상 사용자 정보를 받아 올 수 업다. 따라서 OAuth2.0은 "인증"이 아닌 "인가"라고 부른다. 허가를 내 준다는 뜻이다. 따라서 이러한 방식은 여러 다른 부분에서 사용될 수 있는데, 특정 서비스에 대한 REST API요청에 대해서 토큰을 발급받은 사람에게만 허용하면서 무분별한 API사용을 막음과 동시에 보안성을 높일 수 있다. 메시징툴인 Mattermost가 같은 방식을 사용한다.  ' +
            '--나는 사실 보안에 크게 관심이 많은 건 아니지만, 이러한 인증방식을 보면 당시 개발자들의 고민이 느껴져서 꽤나 흥미롭다. 관련 공부를 할 때 참고한 링크들을 몇개 공유하면서 글을 끝내고자 한다. 영상도 있고 위키도 있지만, 역시 직접 보고 듣는 영상쪽이 가장 도움이 됐다. 사실 가장 좋은 방법은, 다른 서비스들의 OAuth인증방식을 실제로 사용해 보는 것이다.  ' +
            '  ' +
            '- <a href="https://www.youtube.com/watch?v=BNEoKexlmA4">영어지만 기본적인 인증방식을 대략적으로 설명해준다.</a>  ' +
            '- <a href="https://ko.wikipedia.org/wiki/OAuth">위키는 언제나 읽어서 나쁠 건 없는 지식이다.</a>  ' +
            '- <a href="https://opentutorials.org/course/3405">한글 영상이며, 내가 본 영상들 중 가장 구체적으로 설명되어 있다.</a>  ' +
            '- <a href="https://docs.microsoft.com/ko-kr/azure/active-directory/develop/v1-protocols-oauth-code">MS Azure의 인증에 대한 설명이다. 읽어둬서 나쁠 건 없다.</a>'
        },
        {
            title: 'Ansible과 Vagrant',
            date: 1551320535891,
            topic: topic.dev,
            text: "<img src='./static/photos/ansible-vagrant.jpg' style='width: 100%; height: auto;' />  " +
            '  ' +
            '<h3>Ansible과 Vagrant</h3>  ' +
            '--요즘 서버쪽에 관심이 생겨서 인프라나 DevOps관련 공부를 이것저것 하고있는데, 가장 먼저 보였던 것이 Ansible과 Vagrant였다. Ansible은 회사의 서버 관리하는 직원이 언급한적이 있어서 이름은 알고 있었지만 뭐에 쓰는 건지는 몰랐고, Vagrant는 존재 자체를 모르고 있었다. 쉽게 말하자면 Vagrant는 Vagrantfile이라는 파일에 미리 특정 서버를 어떻게 빌드할지를 작성하고 커맨드를 통해 가상환경에서 서버를 올릴 수 있게 해준다. 예컨데 VirtualBox나 VMware와 같은 소프트웨어들 중 무엇을 사용할지, 인터넷 연결은 어떻게 할건지, 가상서버와 서버가 올라간 호스트와의 연결은 어떻게 할건지, 서버 OS는 무엇으로 할건지 등등 여러가지를 설정할 수 있다.  ' +
            '--이렇게 했을때의 장점은, 서버가 필요할 때 마다 일일이 설정을 해줄 필요없이 이전에 이미 작성된 Vagrantfile을 up시켜서 서버를 올리기만 하면 된다는 것이다. "오 편리하겠는데!" 라는 반응은 맞는 얘기지만 반만 맞는 반응이다. 나도 공부하면서 배운 것이지만, 특정 서비스에 여러대의 서버를 사용할때 중요한 것은 같은 환경이어야 한다는 것이다. 게다가 테스트를 진행할 때도 테스트할 서버가 배포할 서버와 같은 환경이어야 제대로 테스트가 가능하다. Vagrant는 미리 설정된 파일을 통해 서버 환경을 동일하게 유지시키므로 안정성을 보장한다. 이러한 특성을 멱등성이라고 한다는데, 같은 실행을 여러번 해도 전부 같은 결과가 나오는 것이다. 결국 Vagrant는 서버 환경의 멱등성을 보장하는데 도움을 준다고 할 수 있다.  ' +
            '--그럼 Ansible은 뭐냐? Vagrant만 있으면 되는 거 아니야? 라는 생각이 들겠지만, 사실 그렇지 않다. Vagrant가 설정 가능한 것은 서버를 올릴때 결정하는 전체적인 환경에 불과하다. 웹 서버를 올린다고 하면, Node.js를 사용할 것인가? 아파치 서버를 사용할 것인가? Node.js를 사용한다고 하면 버전은 무엇인가? 모듈은 무엇을 사용하는가? 프레임워크는 무엇을 사용하는가? 등등 세세한 부분에 대한 설정이 필요하다. 그것을 해주는 것이 바로 Ansible이다. Ansible을 실행하게 되면 파일이나 커맨드로 지시한 명령을 SSH를 통해 서버에 접속한 뒤 자동으로 실행한다. 물론 실패하거나 사용자의 지시에 따라 설정을 멈추거나 할 수도 있다.  ' +
            '--Ansible역시 Vagrant의 방식과 크게 다르지 않은데, YAML파일을 사용하여 하나하나 커맨드를 설정해주면 된다. 서버를 깔고, 필요한 언어가 있으면 설치하고, 필요한 모듈이 있으면 설치한다. 그것 말고도, 필요한 경우 서버를 재실행하도록 명령하거나 모든 작업이 완료되면 특정 작업을 실행하게 하는 등, 꽤나 세세하게 설정을 해놓고 사용할 수 있다. 이 역시 서버 환경의 동일성을 보장하기 위한 것이며, 서버를 설정하는 YAML파일 대로 서버를 설정하면 설정된 서버는 모두 같은 모습을 하게 된다.  ' +
            '--보통 Vagrant와 Ansible을 같이 활용하며, 나는 VirtualBox를 통해 가상서버를 올리도록 했다. 시나리오는 보통 이렇다.  ' +
            '  ' +
            '<h4>1. Vagrantfile을 작성하고 Vagrant를 통해 VirtualBox에 가상서버를 올린다.</h4>' +
            '<h4>2. SSH접속을 통해 서버가 제대로 동작하는지 확인하고 Ansible을 통해 설정할 YAML파일을 작성한다.</h4>' +
            '<h4>3. 작성된 파일을 토대로 Ansible을 통해 서버를 설정하고 실행한다.</h4>' +
            '  ' +
            '--Vagrantfile이나 YAML파일등을 작성하려면 조금 공부를 하고 익숙해지는 시간이 필요하지만 기본적으로는 간단하게 가상서버를 올리고 사용할 수 있다. 테스트 용으로 간단히 사용해도 되고 필요하다면 배포용으로도 얼마든지 동작할 수 있다고 본다.  ' +
            '--그런데 Ansible과 Vagrnat를 사용하다 보면 한가지 기시감을 계속 느낀다. "앵? 이거 완전히 Docker image로 서버 설정하고 Dockerfile로 세팅하는 시나리오 아님?" 이라는 생각이 계속 든다. 이건 내 짐작이지만, 아마 Docker가 영향을 받지 않았다고는 말 못할 것 같다. 애초에 Docker가 더 늦게 나오기도 했고 방식이 너무나도 비슷하다. 다만 표절이라기 보다는 Docker가 기존에 있던 것들을 잘 통합해서 내놓았다는 느낌.  ' +
            '--개인적인 취향을 말하자면, Docke쪽이 더 편리하고 커뮤니티도 활성화되어 있다는 느낌이다. 게다가 다른 도움 없이도 Docker하나로 가상서버를 올리고 관리하는 것이 가능하니 더 간단하다고도 생각한다. 아직 뭐, 나도 초보인 단계라 뭐가 더 좋다고 얘기하기는 어렵고, 필요에 따라서 사용하면 되는게 아닐까?  '
        },
        {
            title: 'Google Stadia',
            date: 1553061391237,
            topic: topic.chat,
            text: "<img src='./static/photos/stadia.jpg' style='width: 100%; height: auto;' />  " +
            '  ' +
            '--Google Stadia가 오늘 발표됐다. 새벽이었기 때문에 실시간으로 보지는 못했고 다음날 일어나서 확인했다. 결론부터 말하자면, 매우 흥미로웠다. 게이머이자 개발자로서 그러려니 넘어갈 수준은 아니었다. 무엇보다도 주체가 그 구글이니 말이다. 만약 다른 회사에서 비슷한 프로젝트를 하겠다고 했다면 그렇게 흥분하지는 않았을 테지만 이건 IT기술의 첨단을 달리는 구글의 발표다. 그 이름값 하나만으로도 Stadia는 제대로 나올 것이 분명했다. 발표를 보는동안, 계속해서 두가지 상상만 했다. 스트리밍 방식을 통한 실제 게임 플레이에 대한 상상과, 서버와 서비스를 어떻게 구현했을지에 대한 기술적인 상상이다. 물론 Stadia는 단순한 게임 스트리밍 플랫폼으로 개발되고 있는 것 만은 아니고, 일종의 개임개발/플레이를 위한 멀티유즈 플랫폼이 될 것이지만 내 흥미는 그 두가지 상상 뿐이었다.  ' +
            '--먼저 첫번째 상상에 대한 얘기를 먼저 해보자. 나는 부정할 필요도 없이 게임을 좋아한다. 굉장히 어렸을 때 부터 이미 게임을 해 왔으며, 내가 초등학생일 당시 PC방이 생기고 집에 컴퓨터가 보급되기 시작했다. 하지만 컴퓨터는 흔한 물건이 아니었기 때문에 집에 컴퓨터가 없는 애들은 있는 집에 찾아가서 같이 하거나 PC방을 가야만 했다. 요즘에는 사정이 많이 좋아져서 컴퓨터를 가지지 않은 집이 더 적은 수준이지만, 게임의 사양이 새로운 문제로 떠올랐다. 현대의 AAA급 게임은 너무 무겁다는 것이다. 모바일로 플레이 불가능 한 것은 물론이고, 노트북도 어지간해서는 포기하는게 좋다. 게이밍 노트북이 나오기는 하고 있지만, 솔직히 말해볼까? 게이밍 노트북은 돈낭비 그 자체다. 특별한 상황이 아니고서야 데스크탑보다 유리한 상황이 거의 없다.  ' +
            '--데스크탑과 게이밍랩탑의 성능이 동일하다고 가정해 보자. 우선 가격, 컴퓨터의 내부 부품들은 대부분 작으면서 효율이 좋기까지 하면 가격이 기하급수적으로 늘어난다. 메모리만 해도 집적도가 늘어나려면 그만한 기술이 필요하고 기술이라는 건 돈의 다른 말일 뿐이다. 결국 데스크탑보다 작은 크기에 그 많은 고사양 부품들을 우겨 넣으려니 가격은 비싸지고 나온 결과물은 랩탐이라고 하기 민망한 크기다. "작은 게이밍 랩탑도 있거든요!" 응, 아니야. 그런건 다 성능, 가격, 크기에 타협한 것들 뿐이야. 게다가 그마저도 더 좋은 사양의 데스크탑을 살 수 있는 가격이다. 여기서 Stadia가 등장한다면 어떨까?  ' +
            '--Stadia는 클라우드에 있는 컴퓨터에서 게임이 실행되고 사용자는 그걸 스트리밍 받기만 하면 된다. 결국 인터넷과 영상을 볼 최소한의 사양만 있으면 그래픽카드 두개씩 달고 수냉식이니 뭐니 주렁주렁 달 필요가 없다는 말이다. 심지어 실제 시연에서는 모바일로 플레이 하는 모습까지 보여줬다. 이게 정말 가능하다면, 모바일에서 디아블로 이모탈 대신 그냥 디아블로3를 하면 되고, 모바일 배그대신 그냥 배그를 하면 된다는 말이다. 게다가 노트북이 한 것 처럼 크기를 줄이기 위해 가격과 성능을 포기할 필요조차도 없다. 한가지 더 좋은 점은, 세계최고 민폐국가 때문에 대두된 게임핵 문제를 걱정할 필요가 없다는 것이다. 게임핵은 게임 사용자 개인의 컴퓨터에서 실행되기 때문에 정 핵을 깔아서 쓰고 싶으면 최고 수준을 가진 구글의 서버보안을 뚫어야 할 것이다.  ' +
            '--조금 더 멀리 가보면, PC방 사장들도 Stadia만 쓴다는 가정하에, 더이상 컴퓨터 업그레이드를 위해 몇천만원씩 쓸 필요가 없다. 여러가지 얘기를 했지만, Stadia가 성공한다면 게임업계의 급격한 변화를 가져올 것이다. 나의 상상을 얘기하자면, 테스크탑 조차 필요없이 모니터만 두고 게임하다가 나갈 일이 있으면 그냥 단순히 모바일로 접속을 옮겨서 플레이 하는 것이다. 이게 상상이 아니라 실제로 가능하다는게 신통할 뿐이다.  ' +
            '--두번째 상상으로 가보자. 게이머인 나는 마냥 기뻐하고 있지만 개발자인 나는 심각한 생각을 여러가지 하고 있었다. 사실 가장 먼저 든 생각은 ping이었다. 스트리밍이라는 건 결국 실시간으로 데이터를 보낸다는 얘기고 서버의 데이터 전달에는 물리적인 거리가 생긴다. 안그래도 멀티플레이 게임에서 ping은 중요한 부분이다. ping이 높으면 다른 플레이어와의 상호작용에 시간적 차이를 만들고 이는 절대 쾌적하지는 않다. 인터넷의 속도가 비교도 못할만큼 빠르면 신경쓸 것 없겠지만 대부분은 그렇지 못하니까 말이다. 서버를 분산하는 것도 문제가 될 수 있다. 서버들은 보통 여러대로 나눠서 서버로 들어오는 사용자들의 요청을 여러대의 서버에 나눠 보냄으로써 부하를 줄인다. 그런데 게임을 스트리밍 하려면 게임을 실제로 구동해야 하며, 요즈음의 게임들이 다 그렇지만, 상당한 자원을 소비한다. 웹 서버의 작업은 게임에 비하면 서버에 전해지는 부하의 크기가 작은 편이다. 결국 많은 유저를 위해서는 엄청나게 많은 서버가 필요해 질 것이다.  ' + 
            '--내가 의문을 가지면서도 사실 어떻게 해야할지 잘 모르겠다. 아마도 게임을 구동하는 서버와 데이터를 보내는 서버를 따로 두지 않을까 싶다. 그렇지 않고서야 게임구동서버의 부하가 너무 커진다. 뭐, 사실 내가 이런 고민을 한다고 뭐가 어떻게 되는 건 아니다. 구글의 천재들이 알아서 해결할 문제이며, 아마도 답을 찾아내겠지. 하지만 개발자로서 흥미로운 부분이기는 하다. 구글 직원이 와서 "Stadia는 이런식으로 서버를 구성할거야!" 라고 말해준다면 좋을텐데 말이다.  ' +
            '--일단 나는 계속해서 주시할 생각이다. 올해 출시를 한다고 했고, 여름에 더 자세한 정보를 줄 수 있다고 했으니 과연 게이머의 희망이 될지 또하나의 망한 서비스가 될지 두고보면 알 것이다. 개인적으로는 전자였으면 좋겠다고 생각하고 있다.  '
        },
        {
            title: 'AWS를 이용한 블로그 배포와 알고리즘',
            date: 1555312150146,
            topic: topic.chat,
            text: "<img src='./static/photos/aws.png' style='width: 100%; height: auto;' />  " +
            '  ' +
            '<h2>AWS를 이용한 블로그 배포</h2>  ' +
            '--4월 17일 ~ 18일에 코엑스에서 열리는 AWS Summit Seoul에 참가하고자 마음을 먹었을 때, 아무리 그래도 컨퍼런스에 참여하려면 AWS를 좀 알아야 하지 않을까? 싶은 생각에 공부를 조금 시작했었다. 인스턴스 만들고 그룹 설정해서 서버 올리고 로드밸런서 설정하고 도메인 구입하고 등등 AWS기능들을 사용하다 보니 이럴거면 실습도 해볼 겸 블로그를 AWS에 올려보자! 라는 생각이 들어서 실행으로 옮겼다. geekinthepunk.net이라는 도메인을 구매해서 로드밸런서에 연결해서 짜잔! 사실 어려운 일은 전혀 아니었고 인스턴스 자체도 하나만 돌아가면 그만이라 간단한 구조를 가지고 있다. 인스턴스가 하나뿐이라 로드밸런서도 사실 아무 의미 없지만 연습을 위해 구현한 것 뿐이다. 이 글을 보고있는 사람은 당연히 깃허브에 올려놓은 주소를 통해 들어왔을 테니 블로그에 대한 긴 설명은 필요 없을 것이다.  ' +
            '--이 블로그가 한가지 당면한 문제가 있다면, 사실 문제는 아니지만, 블로그에 글을 작성하는 방식을 변경하고 싶다는 것이다. 깃허브의 io페이지를 사용했을 적에는 store를 통해 글을 작성하고 커밋해서 푸시하면 업데이트가 되니까 편했는데, 지금은 코드를 변경하고 싶을 경우 AWS에 직접 배포를 해줘야 하기 때문에 이 방식이 도리어 불편해졌다. 게시판처럼 글을 작성하고 저장하는 방식이 되어야 할 것 같다. 현재 생각중인 계획은, 이미 올라가 있는 Nginx서버는 그대로 두고 내가 가장 자신있는 조합인 Node서버와 MongoDB가 함께 존재하는 인스턴스를 하나 더 올려서 REST API를 통해 데이터를 주고받는 것이다. 서버를 구현하고 올리는 것은 큰 문제가 아닐 것 갗지만, 프론트단에서 코드가 많이 변경되어야 할 것 같아서 손을 대기가 무섭다.  ' + 
            '--빠르면 이번달 안에는 시작해서 다음달 안에 끝을 봤으면 하지만 어떻게 될지는 미지수이다. 그래도 언제가 되었던지 진행을 하기는 할 것이다. 아주 게을러 터진 개발자지만 게으른 만큼 귀찮은 짓을 여러번 해야하는 지금의 상태가 썩 달갑지 않다.  ' +
            '  ' +
            '<h2>알고리즘</h2>  ' +
            '--알고리즘 공부를 시작했다. 정확히는, LeetCode의 문제를 풀기 시작했다. 고해성사타임! 지금까지의 안일했던 코딩을 반성한다. "알고리즘이 무슨 소용이야! 코드만 빨리 작성해서 돌아만 가면 그만이지!"라고 생각했던 스스로를 조금 부끄럽게 생각한다. 알고리즘은 아주 중요하다.  ' +
            '--현대의 컴퓨터는 확실히 빠르다. C언어가 메모리를 할당하는 등 세밀하고 귀찮은 작업이 진행되어야 하는 것에 비해 오늘날의 언어들이 생산성을 중요하게 생각하는 것을 보면 어느정도 짐작이 갈 것이다. 컴퓨터는 메모리 효율이나 프로그램의 구조를 조금 엉성하게 만들어도 크게 느끼지 못할 만큼 빨라졌다. 하지만 그건 어디까지나 "조금"엉성한 수준이지, 시간복잡도가 2의 제곱이 되거나 하면 연산시간이 기하급수적으로 늘어나게 된다. 전에 loop를 돌릴 때 가장 빠른 방법은 무엇인가 궁금해져서 for문이나 forEach같은 것들로 테스틀 했던 적이 있었다. 결론은 그딴거 보다는 구조를 잘 짜는게 중요하다! 라는 것이었다. 결론은, 물론 어느 정도의 속도 차이가 있기는 하겠지만 시간과 메모리 복잡도를 어떻게 구성하느냐가 더 중요하다는 것이었다. 컴퓨터는 빨라졌지만, 그럼에도 개발자는 최소한의 효율성을 고려할 필요가 있다.  ' +
            '--알고리즘이 중요한 이유는 또 한가지가 있다. 바로 개발자 취업에 대한 것이다. 요즈음의 기업들 중 많은 곳들이 개발자를 뽑을 때 대학 성적이나 대학교와 같은 전통적인 기준보다 깃허브의 커밋내역, 코딩테스트 같은 지표를 선호하기 시작했다. 이는 개발자의 배경보다는 본질적인 실력을 더 우선시 하겠다는 움직임이다. 여기서 코딩테스트는 알고리즘을 이용한 특정 문제를 해결하는 과정과 코드를 확인하기 때문에 "어떤 문제에 어떤 알고리즘이 효율적인가?"를 알고 있어야 한다. 좋은 회사일수록 어려운 테스트가 주어질 것은 자명하고, 그걸 해결해야 좋은 회사에서 쾌적하게 개발을 할 수 있다. 당신이 알고리즘을 부정할지라도 취업을 하려면 어쨌든 해야된다 이말이다.  ' +
            '--나의 경우에는 LeetCode에서 처음 문제를 풀 때 무차별 대입 방식으로 풀었더니 효율적인 방식으로 푼 것 보다 몇배는 더 걸리는 걸 보고 이건 아니다 싶었다. 지금까지 내가 짰던 코드들이 얼마나 비효율적으로 되어있었을지 생각하니 나름 충격적이었다. 이제 시작한 알고리즘 공부다. 꾸준히 해볼 생각이다.  '
        }
    ]
}